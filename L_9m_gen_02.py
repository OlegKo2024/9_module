print('Генераторные сборки')

# Генераторные сборки (генераторы) и списковые сборки (списковые выражения) отличаются способом создания итераторов.
# 1. Списковые сборки (list comprehensions) создают и возвращают целый список сразу. Они используют синтаксис []
# Генераторные сборки (generator expressions) возвращают объект-генератор, который выдает элементы по одному,
# что позволяет экономить память. Используют синтаксис (), например:

my_numbers = [3, 1, 3, 2, 4, 5, 6, 8]

result = (x ** 100 for x in my_numbers)

print(result)  # <generator object <genexpr> at 0x000002DAD9EAC450> - вычисления не произведены

for elem in result:
    print(elem)

print('Демонстрация встроенных функций с ленивыми вычислениями')

list1 = [1, 4, 6, 9]
list2 = [3, 5, 7, 8]

rg = range(10, 20)  # [10, 11, 12, 13, 14, 15, 16, 17, 18, 19] -  создает список
zp = zip(list1, list2)  # [(1, 3), (4, 5), (6, 7), (9, 8)] - объединяет в список кортежей
mp = map(str, list1)  # ['1', '4', '6', '9'] - переводит в строковое значение

print(rg, zp, mp)  # range(10, 30) <zip object at 0x0000020529653C40> <map object at 0x000002052964D990> - функции
# не вычисляли никакой результат

print(list(rg))
print(list(zp))
print(list(mp))

l = [2, 4, 5, 6]
print(list(map(str, l)))  # ['2', '4', '5', '6']

print('СОЗДАНИЕ ФУНКЦИЙ НА ЛЕТУ')
print('lambda - один параметр')

my_lambda = lambda x: x + 10

print(my_lambda(40))
print(type(my_lambda))  # <class 'function'>

list_ = [1, 2, 3, 4, 7, 8]

result = map(lambda x: x + 10, list_)
print(list(result))  # [11, 12, 13, 14, 17, 18]

print('lambda - несколько параметров')

l_01 = [2, 4, 5, 6]
l_02 = [12, 24, 15, 36, 10]

result = map(lambda x, y: x + y, l_01, l_02)
print(list(result))  # [14, 28, 20, 42]

l_01 = [2, 4, 5, 6]
l_02 = [12, 24, 15, 36, 10]
l_03 = [12, 24, 15, 36, 10, 12]

result = map(lambda x, y, z: x + y - z, l_01, l_02, l_03)
print(list(result))  # [2, 4, 5, 6]

print('Вложенные функции')


def get_multiplier(n):
    if n == 2:
        def multiplier(x):
            return x * 4
    elif n == 3:
        def multiplier(x):
            return x * 10
    else:
        raise Exception('Принимаю 2 или 3')
    return multiplier  # возвращаем функцию, которую мы создали внутри функции высшего порядка


my_numbers = [2, 3, 5, 6, 8, 9]

result = map(get_multiplier(2), my_numbers)
print(list(result))

# 1. Вызов get_multiplier(2):
# Когда вы вызываете get_multiplier(2), этот вызов выполняется первым.
# Внутри get_multiplier создаётся функция multiplier, которая умножает аргумент x на 4. Затем эта функция возвращается.
# 2. Создание объекта map с result = map(get_multiplier(2), my_numbers):
# Здесь передаёте возвращаемую функцию (multiplier(x)) как первый аргумент в map(), а my_numbers — как второй аргумент.
# На этом этапе функция multiplier ещё не вызывается. Вместо этого создаётся объект map, который будет применять
# multiplier к каждому элементу из my_numbers по очереди.
# 3. Выполнение функции multiplier(x):
# Функция multiplier(x) будет вызываться только тогда, когда вы начнёте итерироваться по объекту result.
# Это произойдёт, когда вызываете print(list(result)).
# В момент, когда list(result) вызывается, map() начнёт итерироваться по my_numbers. На каждом шаге она возьмёт
# следующий элемент из списка и передаст его в функцию multiplier.
# Таким образом, выполнение multiplier(x) начинается, когда происходит итерирование по result, т.е. когда вы
# фактически вызываете print(list(result)). Каждый элемент из my_numbers будет передан в multiplier, и результат
# будет собираться в список.
# В вашем случае, поскольку get_multiplier(2) возвращает функцию, умножающую на 4, каждый элемент из my_numbers
# будет умножен на 4, и вы получите список [8, 12, 20, 24, 32, 36] в результате вызова print(list(result))

# Порядок выполнения:
# 1. Вызывается get_multiplier(2), создаётся и возвращается функция multiplier, которая умножает на 4.
# 2. С помощью map создаётся объект, готовый применять функцию multiplier ко всем элементам my_numbers, но сама функция
# на данном этапе не выполняется.
# 3. Итерация (вызов multiplier) начинается только при выполнении print(list(result)).

by_3 = get_multiplier(3)
result = map(by_3, my_numbers)
print(list(result))                             # здесь прогоняем функцию и получаем результат

print('Замыкание переменных')


def get_multiplier(n):
    def multiplier(x):
        return x * n

    return multiplier  # возвращаем функцию, которую мы создали внутри функции высшего порядка


my_numbers = [2, 3, 5, 6, 8, 9]

by_n = get_multiplier(3)
print(by_n(5))  # 15 - без запятой,  map не применяется, так как перебор не нужен

by_n = get_multiplier(5)
result = map(by_n, my_numbers)                  # map применяется, когда нужен перебор
print(list(result))  # [10, 15, 25, 30, 40, 45]


def f1():
    def f2():
        print('I am in 2')  # I am in 2

    f2()  # вызвал функцию на втором уровне


f1()


# Исполнение кода:
# 1. Определение f1: Когда вы вызываете f1(), Python начинает выполнять её код.
# 2. Определение f2: Входя в f1, Python видит определение функции f2, но код внутри просто определяет её, не выполняя.
# 3. Вызов f2(): Когда Python доходит до строки f2(), он вызывает функцию f2. При вызове f2(), управление передаётся
# в тело функции f2.
# 4. Вывод: В теле f2 вызывается print('I am in 2'), которое выводит текст на экран.
# 5. Возврат в f1: После завершения выполнения f2, управление возвращается обратно в f1.
# 6. Завершение f1: Так как f1 больше не имеет команд, выполнение завершено.
# Итог: При вызове f2() вы не просто определяете её, а вызываете и выполняете её код сразу, выводя "I am in 2".

def f1():
    def f2():
        print('I am in 2')

    return f2  # Возвращает объект функции f2


my_func = f1()  # my_func теперь ссылается на f2
my_func()  # Вызов f2, который выведет 'I am in 2'

# Исполнение кода:
# 1. Определение f1: Когда вызываете f1(), Python начинает выполнять её код.
# 2. Определение f2: Входя в f1, Python видит определение функции f2, но сейчас она не выполняется.
# 3. Возврат функции f2: Python доходит до строки return f2 и возвращает объект функции f2 (не выполняя её код).
# Это значит, что f2 будет просто сохранена как функция, готовая к вызову, но её код *не* выполняется на этом этапе.
# 4. Присваивание my_func: Возвращённый объект функции f2 сохраняется в переменной my_func
# Теперь, возвращаясь к строке my_func = f1(), переменной my_func присваивается не результат выполнения f2,
# а сама функция f2 как объект. По сути, my_func теперь является ссылкой на функцию f2.
# 5. Вызов функции my_func(): Когда вызываем my_func(), Python переходит к функции f2, как если бы вызвали ее напрямую.
# - Теперь управление передаётся в тело функции f2.
# 6. Вывод: В теле f2 вызывается print('I am in 2'), которое выводит текст на экран.
# 7. Возврат в my_func: После завершения выполнения f2, управление возвращается к my_func.
# 8. Завершение my_func: Это завершает выполнение.
# Итог: В этом случае функция f2() не вызывается немедленно, а возвращается как объект и вызывается позже,
# когда вы вызываете my_func().

# Краткие различия
# - При вызове функции f2() в f1(), код внутри f2 выполняется сразу, и результаты видны немедленно.
# - При возврате функции через return f2, выполнение кода внутри f2 откладывается до тех пор, пока вы явно не вызовете
# my_func(), в результате чего код в f2 выполнится позднее.


print('Возвращаясь к нашему примеру, выполнение кода return x * n откладывается до print(by_n(5))')


def get_multiplier(n):  # с by_n = get_multiplier(3) передаем 3, как n  и запоминаем

    def multiplier(x):  # c print(by_n(5)), получив return multiplier, передаем 5 или my_numbers в multiplier(x):

        return x * n  # перемножаем

    return multiplier  # возвращаем функцию, которую мы создали внутри функции высшего порядка


my_numbers = [2, 3, 5, 6, 8, 9]

by_n = get_multiplier(3)
print(by_n(5))  # 15 - получаем результат

print('Пример матрицы и того, что не стоит передавать в функцию верхнего уровня изменяемые объекты')

from pprint import pprint


def matrix(some_list):
    def multiply(x):
        arr = []
        for element in some_list:
            arr.append(element * x)
        return arr

    return multiply


my_numbers = [2, 3, 4, 5, 6, 7]
his_numbers = [10, 100, 1000, 10000, 100000, 1000000]

start_matrix = matrix(my_numbers)
result = map(start_matrix, his_numbers)
pprint(list(result))

my_numbers.extend([8, 9])
print(my_numbers)
start_matrix = matrix(my_numbers)
result = map(start_matrix, his_numbers)
pprint(list(result))

print('Класс, объекты которого вызываются как функции')

class Multiplier:
    def __init__(self, n):
        self.n = n

    def __call__(self, x):
        return x * self.n

# Здесь мы определяем класс Multiplier, который имеет метод __init__ (конструктор) и метод __call__.
# В конструкторе __init__ создаётся объект Multiplier, который принимает 1 аргумент n и присваивает его атрибуту self.n.
# Метод __call__ позволяет объекту вызываться как функцию. Когда вы вызываете объект, например, obj(x), Python на
# самом деле вызывает метод __call__ этого объекта. В данном случае, он будет принимать аргумент x и
# возвращать произведение x и self.n.

# Когда мы говорим о "вызове как функции", мы имеем в виду, что объект определенного класса может быть использован
# так, как если бы он был функцией. Когда вы пишете by_100(10), это выглядит как вызов функции, хотя на самом деле
# by_100 — это экземпляр класса Multiplier, а не обычная функция, а за кулисами, то что реально происходит
# мы имеем by_100.__call__(10)

by_100 = Multiplier(n=100)
# Здесь мы создаём экземпляр класса Multiplier с n=100. Таким образом, атрибут self.n будет равен 100 в этом объекте.
result = by_100(x=10)
# На этом этапе вы вызываете объект by_100 как функцию: by_100(x=10).
# Поскольку мы определили метод __call__, Python вызывает именно этот метод и передаёт x=10 в качестве аргумента.
print(result)                       # 1000

my_numbers = [2, 3, 4, 5, 6, 7]
result = map(by_100, my_numbers)
print(list(result))                 # [200, 300, 400, 500, 600, 700]
# Здесь создаём список my_numbers, содержащий несколько чисел.
# - Затем вызываем функцию map, передавая ей объект by_100 и список my_numbers.
# - Метод map применяет объект by_100 к каждому элементу списка my_numbers, то есть фактически вызывает __call__ для
# каждого числа в массиве.
# - Напрмер: by_100(2), by_100(3), и так далее для всех чисел в списке:
# - by_100(2) вернёт 200
# - by_100(3) вернёт 300
# - by_100(4) вернёт 400
# - и так далее до by_100(7), что вернёт 700.





